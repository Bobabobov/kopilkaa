# Монеткосбор 90-х — описание реализации

## Общая архитектура

Игра «Монеткосбор 90-х» (Coin Catch) — мини-игра на **Next.js 14** и **PixiJS**. Игрок за 30 секунд собирает монеты кликом; промах отнимает жизнь (всего 3). Результат сохраняется в БД и отображается в недельном топе.

**Структура модуля:**

- `app/games/coin-catch/` — страница игры (Next.js)
- `features/games/coin-catch/`
  - `_types/` — типы и конфиг (GameState, Coin, LeaderboardEntry, GAME_CONFIG)
  - `_services/api.ts` — запросы: getLeaderboard(), submitScore(), getMe()
  - `_core/` — движок PixiJS, сцены, системы (spawn, adaptive)
  - `_components/` — CoinCatchPage, GameCanvas, панель топа

---

## 1. Страница и разметка (адаптив)

**Файл:** `CoinCatchPage.tsx`

- **Контейнер страницы:** `width: 100vw`, `height: 100dvh`, отрицательные margin по горизонтали (`calc(-50vw + 50%)`), чтобы выйти за пределы родительского padding и занять весь экран по ширине. `overflow-hidden`, чтобы не было горизонтального скролла.
- **Шапка (header):** фиксированная высота, `flex-shrink-0`. Содержит: «Назад» (Link на /games), заголовок «Монеткосбор 90-х» (на мобильных коротко «90-х» через `hidden sm:inline` / `sm:hidden`), отступ справа для баланса. Адаптивные отступы `px-3 sm:px-5`, `py-2.5 sm:py-3`, шрифты `text-sm sm:text-base` и `text-base sm:text-xl`.
- **Игровая область:** `flex-1 min-h-0` — занимает оставшуюся высоту под шапкой, не вылезает за экран. Внутри — единственный блок с `GameCanvas`.
- **Загрузка:** спиннер + текст «Загрузка...», `minHeight: 100dvh`.
- **Не авторизован:** карточка по центру с призывом войти, кнопка «Войти» (Link на `/?modal=auth`). Карточка адаптивна: `max-w-md`, `p-6 sm:p-8`, `text-xl sm:text-2xl` и т.д.

Все размеры и отступы завязаны на Tailwind-брейкпоинт `sm` (768px), плюс относительные единицы (vw, dvh) для корректной работы на мобильных и при смене ориентации.

---

## 2. Игровой контейнер и движок (адаптив)

**Файл:** `GameCanvas.tsx`

- **Контейнер канваса:** `relative w-full h-full`, `min-h-0`, `maxWidth: 100vw`, `maxHeight: 100%` — заполняет область под шапкой и не выходит за её границы.
- **Инициализация:** после монтирования создаётся `GameEngine` с контейнером-div. Размеры канваса задаёт движок при `init()` и при каждом `handleResize()` по размеру контейнера и видимой области.
- **Кнопка «Топ недели»:** абсолютное позиционирование `top-2 right-2 sm:top-4 sm:right-4`, поверх игры. На мобильных подпись «Топ», на десктопе — «Топ недели».

---

## 3. Движок PixiJS и видимая область

**Файл:** `engine.ts`

**Инициализация размера:**

- Берётся видимая область: `getVisibleViewport()` (см. ниже).
- Ширина/высота игры = минимум из (ширина/высота контейнера, ширина/высота видимой области), с ограничением снизу 320px.
- PixiJS Application создаётся с этими `width` и `height`. Рендер и игровая логика работают в «пикселях экрана» — без фиксированного design resolution, поле масштабируется под реальный размер области.
- Canvas растягивается на 100% контейнера (`position: absolute`, `width/height: 100%`), `touchAction: none` для тапов по монетам.

**Ресайз:**

- Подписка на: `window.resize`, `visualViewport.resize` и `visualViewport.scroll` (важно на мобильных при появлении/скрытии адресной строки), плюс `ResizeObserver` на контейнер.
- В `handleResize()` заново вычисляются `w`, `h` (так же через видимую область и контейнер), вызывается `app.renderer.resize(w, h)`.
- Текущей сцене передаётся viewport `{ width: w, height: h, scale: 1, offsetX: 0, offsetY: 0 }`:
  - **Menu:** `menuScene.onResize(viewport)` — пересборка UI (см. ниже).
  - **Play:** `playScene.onResize(viewport)` — перерисовка фона и HUD.

Так реализован адаптив игры: при изменении размера окна или контейнера (в т.ч. на мобильных) поле и интерфейс пересчитываются и не выходят за видимую область.

**Важно:** при повторном старте игры обработчик клика по сцене снимается и вешается заново (`stage.off` перед `stage.on`), чтобы не было двойного срабатывания (сбор + промах).

---

## 4. Система «видимой области» и мобилки

**Файл:** `_core/systems/adaptive.ts`

- **getVisibleViewport():** возвращает `width` и `height` видимой области. В браузере используется `window.visualViewport` (если есть) — он учитывает клавиатуру, адресную строку, safe area. Иначе — `window.innerWidth/innerHeight`. Это не даёт игровому полю уезжать за край экрана на телефонах.
- **isMobile():** `window.innerWidth < 768`. Используется для размера монет (крупнее на мобильных) и опционально для UI.
- **calculateViewport():** запасной расчёт масштаба по design size (в текущей реализации поле не использует фиксированный design resolution; размер задаётся напрямую из контейнера и видимой области).

---

## 5. Игровая логика

**Конфиг** (`_types/index.ts`, `GAME_CONFIG`):

- Длительность раунда: 30 с.
- Жизни: 3.
- Интервал спавна: 800 мс.
- Срок жизни монеты: 4500 мс (не собранная монета исчезает).
- Радиус монеты: 30 (десктоп), 45 (мобильный) — ориентиры; фактический радиус считается в spawn от размера экрана.

**Спавн монет** (`_core/systems/spawn.ts`):

- За один тик спавнится **от 1 до 4 монет** (`spawnCoinBatch()` в движке).
- Радиус монеты: `minSide * 0.055`, ограничен диапазоном 18…48 (мобильный) или 18…40 (десктоп).
- Позиция: случайная точка внутри «безопасной зоны» — отступы от краёв `marginX`, `marginY` (минимум radius+20 и 5–6% от ширины/высоты), чтобы монеты не обрезались и не спавнились вплотную к краю.
- У каждой монеты есть `spawnedAt: Date.now()` для проверки срока жизни.

**В движке:**

- По интервалу 800 мс вызываются `removeExpiredCoins()` (удаление монет старше `coinLifetimeMs`) и `spawnCoinBatch()`.
- Клик по stage: проверка попадания в радиус какой-либо монеты. Попадание — +1 очко, удаление монеты, анимация сбора. Промах — −1 жизнь (игнорируются клики в первые 500 мс после старта, чтобы не засчитать клик по кнопке «Начать игру»).
- Таймер игры: каждую секунду `timeLeft` уменьшается; при 0 или 0 жизней вызывается `endGame()`, отправка счёта на сервер (из GameCanvas), показ GameOver.

---

## 6. Сцены PixiJS и их адаптив

**MenuScene** (`_core/scenes/MenuScene.ts`):

- Масштаб UI: `scale = getScale(width, height)` = `minSide/400`, ограничен 0.6…2.5.
- Все размеры (шрифты, панель, кнопка) зависят от `scale` и `width/height`: заголовок, подзаголовок, описание, центральная панель (карточка), кнопка «Начать игру». При ресайзе вызывается `onResize(viewport)` → полная пересборка UI через `buildUI(viewport.width, viewport.height)` (старый uiRoot удаляется, создаётся новый). Так меню остаётся читаемым на любом разрешении.

**PlayScene** (`_core/scenes/PlayScene.ts`):

- Фон: полосы и сетка, количество/шаг зависят от `sceneWidth`/`sceneHeight` (например, полос по высоте `floor(height/24)`).
- HUD: панель с очками, жизнями, временем. Ширина/высота панели, размер шрифтов, отступы считаются от `minSide` и `scale = minSide/400`. Подписи «Очки», «Жизни», «Сек» и значения выводятся в одну колонку с адаптивными позициями. При `onResize(viewport)` пересоздаются фон и весь UI (setupBackground, setupUI), затем обновляется состояние (score, lives, time).
- Монеты рисуются в координатах экрана; при ресайзе канвас уже нового размера, старые монеты очищаются при смене сцены/рестарте.

**GameOverScene** (`_core/scenes/GameOverScene.ts`):

- Показ при каждом `show(score)`: размеры берутся из `app.screen`, масштаб от `minSide/400`. Карточка по центру, заголовок «Игра окончена», блок счёта, кнопки «Сыграть ещё» и «Таблица недели». Кнопки с hover/active, без отдельного onResize — при следующем открытии используются актуальные размеры экрана.

Общий принцип адаптива в сценах: все размеры (px, шрифты, отступы) выводятся из текущих `width`, `height` и производного `scale`, либо пересобираются при `onResize`, чтобы интерфейс не «уплывал» и не обрезался на разных экранах.

---

## 7. Топ недели (панель и адаптив)

**Данные:**

- API `GET /api/games/coin-catch/leaderboard` возвращает до 20 записей за текущую неделю (weekKey в формате YYYY-Www). Для каждой записи подтягивается пользователь: avatar, vkLink, telegramLink, youtubeLink. В ответе: rank, displayName, score, userId, avatarUrl, vkLink, telegramLink, youtubeLink.

**Верстка панели** (`GameCanvas.tsx`, компонент `LeaderboardPanel`):

- Позиция: `absolute top-2 right-2 sm:top-4 sm:right-4`, поверх игры.
- Ширина: `w-[min(calc(100vw-1rem),20rem)]` на мобильных, `sm:w-72` на больших экранах, `max-w-[calc(100vw-1rem)]` — не вылезает за экран по горизонтали.
- Высота панели: `maxHeight: min(85dvh, calc(100vh - 5rem))` — не больше 85% высоты окна и не ниже шапки (5rem под заголовок страницы). Панель не уходит за нижний край экрана.
- Внутри: шапка «Топ недели» (flex-shrink-0), прокручиваемый список, кнопка «Закрыть» (flex-shrink-0) — кнопка всегда видна внизу.
- Список: у контейнера списка `maxHeight: 12.5rem` (~5 строк по высоте ряда). Внутри — все 20 записей; видно сразу около 5, остальные — скроллом. `overflow-y: auto`, `overflow-x: hidden`, `overscroll-contain`, `touch-pan-y`, `WebkitOverflowScrolling: touch` — удобная прокрутка и скроллбаром, и тапом/свайпом на мобильных.

**Содержимое строки:** место, аватар (круг, fallback `/default-avatar.png`), имя (Link на `/profile/[userId]` если есть userId), иконки VK/Telegram/YouTube (ссылки из профиля), счёт. Размеры текста и аватаров: `text-xs sm:text-sm`, `w-7 h-7 sm:w-8 sm:h-8` и т.д.

Итог: топ показывает 5 строк «в окне», листается до 20, панель и список адаптивны по ширине/высоте и не перекрывают весь экран.

---

## 8. API и сохранение счёта

- **GET /api/games/coin-catch/leaderboard** — топ-20 за неделю, с полями пользователя (аватар, соцсети). WeekKey по понедельнику.
- **POST /api/games/coin-catch/score** — сохранение счёта (тело: `{ score }`), авторизация через сессию, подставляются userId, displayName, gameKey, weekKey. Есть ограничения и защита от спама.

Счёт отправляется один раз при окончании игры (в GameCanvas, по callback от движка).

---

## 9. Итог по адаптиву

| Место                  | Как сделано                                                                                                                              |
| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| Страница               | 100vw × 100dvh, шапка и блок игры через flex, брейкпоинты sm                                                                             |
| Канвас                 | Размер из контейнера и getVisibleViewport(); ресайз по window, visualViewport, ResizeObserver                                            |
| Поле игры              | Pixi renderer resize по w×h; монеты в безопасной зоне; радиус от размера экрана и isMobile                                               |
| Меню / Play / GameOver | Масштаб от width, height, minSide; onResize пересобирает или пересчитывает UI                                                            |
| Топ недели             | Панель: ограничение по ширине и maxHeight по dvh/vh; список — фиксированная высота «окна» (~5 строк), прокрутка до 20; touch и скроллбар |

В результате игра и интерфейс подстраиваются под размер окна и контейнера, не выходят за видимую область на мобильных и остаются удобными при скролле и смене ориентации.
